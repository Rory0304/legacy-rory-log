0:["jJWKgzK4__nUtZUbYiByg",[[["",{"children":["articles",{"children":[["slug","react-hydration-error","d"],{"children":["__PAGE__?{\"slug\":\"react-hydration-error\"}",{}]}]}]},"$undefined","$undefined",true],"$L1",[[],["$L2",null]]]]]
3:HL["/_next/static/css/5c5a75f489881250.css",{"as":"style"}]
4:I{"id":"7470","chunks":["171:static/chunks/171-27e9781882796964.js","509:static/chunks/509-b350357ed4ae50b8.js","185:static/chunks/app/layout-ea98c90d1ceb41e6.js"],"name":"","async":false}
5:I{"id":"2392","chunks":["171:static/chunks/171-27e9781882796964.js","509:static/chunks/509-b350357ed4ae50b8.js","185:static/chunks/app/layout-ea98c90d1ceb41e6.js"],"name":"","async":false}
6:I{"id":"3127","chunks":["171:static/chunks/171-27e9781882796964.js","793:static/chunks/793-b7dfecf1261b522f.js","879:static/chunks/879-34fed0499e457ec4.js","83:static/chunks/app/articles/[slug]/page-4a5ca5c9cacbd034.js"],"name":"","async":false}
7:I{"id":"225","chunks":["171:static/chunks/171-27e9781882796964.js","793:static/chunks/793-b7dfecf1261b522f.js","879:static/chunks/879-34fed0499e457ec4.js","83:static/chunks/app/articles/[slug]/page-4a5ca5c9cacbd034.js"],"name":"","async":false}
8:I{"id":"3211","chunks":["272:static/chunks/webpack-dfb90da3cba0a657.js","253:static/chunks/bce60fc1-6099b244b79edbde.js","769:static/chunks/769-ad268502183160ca.js"],"name":"","async":false}
9:I{"id":"5767","chunks":["272:static/chunks/webpack-dfb90da3cba0a657.js","253:static/chunks/bce60fc1-6099b244b79edbde.js","769:static/chunks/769-ad268502183160ca.js"],"name":"","async":false}
b:I{"id":"5788","chunks":["171:static/chunks/171-27e9781882796964.js","793:static/chunks/793-b7dfecf1261b522f.js","879:static/chunks/879-34fed0499e457ec4.js","83:static/chunks/app/articles/[slug]/page-4a5ca5c9cacbd034.js"],"name":"","async":false}
1:[["$","html",null,{"lang":"ko","children":[["$","head",null,{"children":[["$","link",null,{"rel":"stylesheet","as":"style","crossOrigin":"","href":"https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.6/dist/web/static/pretendard.css"}],["$","link",null,{"rel":"stylesheet","as":"style","crossOrigin":"","href":"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css","title":"light"}],["$","link",null,{"rel":"stylesheet","as":"style","crossOrigin":"","href":"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css","title":"dark"}],["$","link",null,{"rel":"icon","href":"/favicon.ico"}]]}],["$","$L4",null,{"children":["$","$L5",null,{"children":["$","body",null,{"children":[["$","$L6",null,{}],["$","$L7",null,{"children":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","articles","children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","articles","children",["slug","react-hydration-error","d"],"children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$La",null],"segment":"__PAGE__?{\"slug\":\"react-hydration-error\"}"},"styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/5c5a75f489881250.css","precedence":"next"}]]}],"segment":["slug","react-hydration-error","d"]},"styles":[]}],"segment":"articles"},"styles":[]}]}],["$","$Lb",null,{}]]}]}]}]]}],null]
2:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
c:I{"id":"6260","chunks":["171:static/chunks/171-27e9781882796964.js","793:static/chunks/793-b7dfecf1261b522f.js","879:static/chunks/879-34fed0499e457ec4.js","83:static/chunks/app/articles/[slug]/page-4a5ca5c9cacbd034.js"],"name":"","async":false}
d:I{"id":"9131","chunks":["171:static/chunks/171-27e9781882796964.js","793:static/chunks/793-b7dfecf1261b522f.js","879:static/chunks/879-34fed0499e457ec4.js","83:static/chunks/app/articles/[slug]/page-4a5ca5c9cacbd034.js"],"name":"","async":false}
e:I{"id":"5851","chunks":["171:static/chunks/171-27e9781882796964.js","793:static/chunks/793-b7dfecf1261b522f.js","879:static/chunks/879-34fed0499e457ec4.js","83:static/chunks/app/articles/[slug]/page-4a5ca5c9cacbd034.js"],"name":"","async":false}
a:[["$","$Lc",null,{"title":"Articles | rory dev","description":" Mainly handle development-related knowledge and project retrospectives."}],["$","$Ld",null,{"article":{"__typename":"Article","sys":{"__typename":"Sys","id":"uZHtg9NaaldVQ23t8iWZc"},"title":"Next 13 react hydration error","slug":"react-hydration-error","content":"<h3 id=\"error-message\">Error Message</h3>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-title class_\">Error</span>: <span class=\"hljs-title class_\">Text</span> content does not match server-rendered <span class=\"hljs-variable constant_\">HTML</span>.\n<span class=\"hljs-title class_\">Warning</span>: <span class=\"hljs-title class_\">Text</span> content did not match. <span class=\"hljs-title class_\">Server</span>: <span class=\"hljs-string\">\"5/16/2023\"</span> <span class=\"hljs-title class_\">Client</span>: <span class=\"hljs-string\">\"2023. 5. 16.\"</span>\n<span class=\"hljs-title class_\">See</span> more info <span class=\"hljs-attr\">here</span>: <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//nextjs.org/docs/messages/react-hydration-error</span>\n</code></pre><h3 id=\"context\">Context</h3>\n<p>Next.js 13 버전 작업 도중, 서버 사이드에서 받아온 날짜 데이터를 클라이언트 사이드에서 변환하여 렌더링했을 때 오류가 발생했다. </p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-string\">\"use client\"</span>;\n\n// article props 는 서버 사이드에서 받아옴\nconst ArticleTemplate: React.FC&lt;ArticleTemplateProps&gt; = ({ article }) =&gt; {\n    const localizedDate = new Date(date).toLocaleDateString();\n    ...\n    <span class=\"hljs-keyword\">return</span> (\n        &lt;time dateTime={localizedDate}&gt;\n            {localizedDate}\n        &lt;/time&gt;\n    )\n}\n</code></pre><h3 id=\"solution\">Solution</h3>\n<p>우선 위 오류 메세지에 나온 참고 링크를 살펴보면 원인을 설명해주고 있다.</p>\n<blockquote>\n<p>While rendering your application, there was a difference between the React tree that was pre-rendered (SSR/SSG) and the React tree that rendered during the first render in the Browser. The first render is called Hydration which is a&nbsp;<a href=\"https://react.dev/reference/react-dom/hydrate\">feature of React</a>.</p>\n<p>This can cause the React tree to be out of sync with the DOM and result in unexpected content/attributes being present.</p>\n</blockquote>\n<p>SSR/SSG 를 통해 pre-render 되는 리액트 트리와 브라우저 단에서 render 되는 리액트 트리가 서로 다르기 때문에 발생하는 문제이고 이 과정은 리액트 기능 중 하나인 ‘Hydration’ 과 관련이 있다고 한다. </p>\n<p><strong>Hydration 이란?</strong></p>\n<p>Hydration 의 개념을 이해하기 위해서는 CSR 과 SSR의 대표 특징을 먼저 익혀두면 좋다. 이를 Time to Interact 와 Time to View 로 간단히 설명해보자면 다음과 같다. </p>\n<ul>\n<li>Time to View (TTV): 사용자가 웹사이트를 보기까지 걸리는 시간</li>\n<li>Time to interact (TTI): 사용자가 웹에서 클릭 이벤트 같은 상호작용이 가능하게 되는데 걸리는 시간</li>\n</ul>\n<p><strong>1) CSR</strong></p>\n<p><img alt=\"CSR\" src=\"https://github.com/Rory0304/rory-public-docs/blob/main/rory-dev/articles/react-hydration-error/csr.png?raw=true\"></p>\n<ul>\n<li>유저가 웹 사이트를 방문(Request)하면, 브라우저는 최소한의 index.html 파일과 내부의 JS 번들(Response)을 다운 받음.</li>\n<li>브라우저는 다운이 완료되면 JS 를 실행하고, API 를 통해 데이터를 패치해서 동적 컨텐츠를 파싱 후 최종 컨텐츠를 보여줌</li>\n<li>사용자가 페이지 이동시, 다시 서버에 request 를 보내지 않고 초기에 받은 JS 파일을 통해 렌더링함</li>\n<li>Time to View === Time to Interact</li>\n</ul>\n<p><strong>2) SSR</strong></p>\n<p><img alt=\"SSR\" src=\"https://github.com/Rory0304/rory-public-docs/blob/main/rory-dev/articles/react-hydration-error/ssr.png?raw=true\"></p>\n<ul>\n<li>유저가 웹 사이트를 방문 (Request) 하면, 서버는 콘텐츠가 렌더된 초기 HTML 파일을 준비함</li>\n<li>초기 HTML 파일은 JS 이벤트 같은 추가 렌더링 작업을 위해 브라우저에 보내짐. 이때 유저는 해당 브라우저를 볼 수는 있지만 상호작용을 할 수는 없음 (Response, Time to View)</li>\n<li>브라우저는 해당 HTML 파일을 다운 받아서, 인터렉션이 가능하도록 작업을 진행 후, 최종 페이지를 유저에게 전달함 (Time to Interact)</li>\n</ul>\n<p><strong>3) 정리</strong></p>\n<p>React 는 콘텐츠가 없는 HTML Document 파일과 JS 번들 파일을 서버로부터 다운 받은 후, 클라이언트 단에서 자바스크립트 액션을 통해 데이터 패칭 및 Root DOM 요소를 찾아 React 엘리먼트를 하위로 주입하는 과정을 거쳐 웹을 구성한다.</p>\n<p><img alt=\"Next.js 로 만들어진 웹 접속 시, 네트워크 상태 (HTML Document 를 다운 받은 후, script로 DOM 요소를 찾아가며 코드 매칭되는 모습)\" src=\"https://github.com/Rory0304/rory-public-docs/blob/main/rory-dev/articles/react-hydration-error/next-network.png?raw=true\"></p>\n<p>Next.js 로 만들어진 웹 접속 시, 네트워크 상태 (HTML Document 를 다운 받은 후, script로 DOM 요소를 찾아가며 코드 매칭되는 모습)</p>\n<p>Next.js 를 사용할 경우, 서버 사이드에서 data fetch 와 더불어, 콘텐츠가 구성된 초기 웹 페이지를 렌더링하여 클라이언트에게 전송한다. 이때 초기 웹 페이지는 자바스크립트 액션이 모두 빠져있는 HTML 형태이고, 클라이언트 단에서 자바스크립트 코드 파일들이 HTML DOM 요소를 찾아가며 매칭이 이루어진다. 이와 같이 서로 매칭이 이루어지는 과정을 React 에서는 Hydration 이라고 한다. </p>\n<p><img alt=\"hydratino-logic\" src=\"https://github.com/Rory0304/rory-public-docs/blob/main/rory-dev/articles/react-hydration-error/hydration-logic.png?raw=true\"></p>\n<p>더 자세한 내용은 아래 링크를 참고하면 좋다. 상당히 자세하게 설명이 되어 있어서 Hydration이 작동하는 방식을 잘 이해할 수 있다. </p>\n<ul>\n<li>Next.js 의 Hydration 이란? : <a href=\"https://helloinyong.tistory.com/315\">https://helloinyong.tistory.com/315</a></li>\n<li>React hydration 관련 코드 : <a href=\"https://react.dev/reference/react-dom/client/hydrateRoot\">https://react.dev/reference/react-dom/client/hydrateRoot</a></li>\n</ul>\n<p>Hydration 과정에서 pre-render 된 결과와 브라우저 단에서 render 되는 결과의 차이 문제의 해결 방법은 아래와 같다. </p>\n<ol>\n<li>서버 사이드와 클라이언트 사이드에서 state가 달라지는 경우, useEffect 내부에서 관리한다.</li>\n</ol>\n<ul>\n<li>문제가 되는 코드</li>\n</ul>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">MyComponent</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-comment\">// This condition depends on `window`. During the first render of the browser the `color` variable will be different</span>\n  <span class=\"hljs-keyword\">const</span> color = <span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-variable language_\">window</span> !== <span class=\"hljs-string\">'undefined'</span> ? <span class=\"hljs-string\">'red'</span> : <span class=\"hljs-string\">'blue'</span>\n  <span class=\"hljs-comment\">// As color is passed as a prop there is a mismatch between what was rendered server-side vs what was rendered in the first render</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">{</span>`<span class=\"hljs-attr\">title</span> ${<span class=\"hljs-attr\">color</span>}`}&gt;</span>Hello World!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>\n}\n</code></pre><p>서버 사이드에서는 window 객체가 없기 때문에 color 초기 변수가 ‘red’ 로 정의되지만, 브라우저단에서는 ‘blue’ 이다. 서버 사이드와 브라우저에서 초기 렌더 결과, color 변수의 상태가 각각 다르기 때문에 문제가 발생한다. </p>\n<ul>\n<li>해결 방법</li>\n</ul>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-comment\">// In order to prevent the first render from being different you can use `useEffect` which is only executed in the browser and is executed during hydration</span>\n<span class=\"hljs-keyword\">import</span> { useEffect, useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">MyComponent</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-comment\">// The default value is 'blue', it will be used during pre-rendering and the first render in the browser (hydration)</span>\n  <span class=\"hljs-keyword\">const</span> [color, setColor] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-string\">'blue'</span>)\n  <span class=\"hljs-comment\">// During hydration `useEffect` is called. `window` is available in `useEffect`. In this case because we know we're in the browser checking for window is not needed. If you need to read something from window that is fine.</span>\n  <span class=\"hljs-comment\">// By calling `setColor` in `useEffect` a render is triggered after hydrating, this causes the \"browser specific\" value to be available. In this case 'red'.</span>\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">setColor</span>(<span class=\"hljs-string\">'red'</span>), [])\n  <span class=\"hljs-comment\">// As color is a state passed as a prop there is no mismatch between what was rendered server-side vs what was rendered in the first render. After useEffect runs the color is set to 'red'</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">{</span>`<span class=\"hljs-attr\">title</span> ${<span class=\"hljs-attr\">color</span>}`}&gt;</span>Hello World!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>\n}\n</code></pre><p>window 객체 존재 여부에 따른 의존을 없앤다. hydration 과정에서 useEffect가 실행 되면서 변수의 상태를 제어해준다. time to view 에서는 ‘blue’ 로 정의되어 있으나, time to interact 에서는 ‘red’ 로 상태가 변화하는 방식으로 초기 state 를 정의해줄 수 있다. </p>\n<ol start=\"2\">\n<li>HTML 을 적절히 사용한다.</li>\n</ol>\n<ul>\n<li>문제가 되는 코드</li>\n</ul>\n<pre><code class=\"hljs language-tsx\">\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">IncorrectComponent</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        This is not correct and should never be done because the p tag has been\n        abused\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Image</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/vercel.svg\"</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"\"</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"30\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"30\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n  )\n}\n</code></pre><p>p 태그 내부에 div 태그를 사용하여 문제가 발생한다.</p>\n<blockquote>\n<p>The </p><div> tag can NOT be inside&nbsp;<strong><a href=\"https://www.w3docs.com/learn-html/html-p-tag.html\"></a></strong><p><strong><a href=\"https://www.w3docs.com/learn-html/html-p-tag.html\"></a></strong>&nbsp;tag, because the paragraph will be broken at the point, where the </p><div> tag is entered.\n출처: <a href=\"https://www.w3docs.com/learn-html/html-div-tag.html\">https://www.w3docs.com/learn-html/html-div-tag.html</a><p></p>\n</div></div></blockquote>\n<ul>\n<li>해결 방법</li>\n</ul>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">CorrectComponent</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        This is correct and should work because a div is really good for this\n        task.\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Image</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/vercel.svg\"</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"\"</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"30\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"30\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  )\n}\n</code></pre><p>HTML 태그를 적절하게 사용해준다. </p>\n<ol start=\"3\">\n<li><em>suppressHydrationWarning 을 설정해준다.</em></li>\n</ol>\n<p>이 방법은 timestamp 와 같이 렌더 트리 간의 exact match 를 보장해주지 못할 경우, warning 을 띄워주지 않는 방법이다. 이 방법은 성능상의 이슈가 있을 수 있기 때문에 남용하지 않는 것이 좋다.</p>\n<blockquote>\n<p>If you use <a href=\"https://react.dev/reference/react-dom/server\">server rendering,</a> normally there is a warning when the server and the client render different content. In some rare cases (like timestamps), it is very hard or impossible to guarantee an exact match. If you set <code>suppressHydrationWarning</code> to <code>true</code>, React will not warn you about mismatches in the attributes and the content of that element. It only works one level deep, and is intended to be used as an escape hatch. Don’t overuse it.\n출처: <a href=\"https://ko.legacy.reactjs.org/docs/dom-elements.html#suppresshydrationwarning\">https://ko.legacy.reactjs.org/docs/dom-elements.html#suppresshydrationwarning</a></p>\n</blockquote>\n<h2 id=\"참고-자료\">참고 자료</h2>\n<p><strong>CSR 과 SSR 차이</strong></p>\n<ul>\n<li><a href=\"https://ajdkfl6445.gitbook.io/study/web/csr-vs-ssr-vs-ssg\">https://ajdkfl6445.gitbook.io/study/web/csr-vs-ssr-vs-ssg</a></li>\n<li><a href=\"https://velog.io/@juurom/TIL-react-hydration-error-%EC%9B%90%EC%9D%B8-%EB%B0%8F-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95-feat.-react-calendar\">https://velog.io/@juurom/TIL-react-hydration-error-원인-및-해결방법-feat.-react-calendar</a></li>\n</ul>\n<p><strong>Hydration 개념</strong></p>\n<ul>\n<li><a href=\"https://aboutmonica.com/blog/server-side-rendering-react-hydration-best-practices/#summary\">https://aboutmonica.com/blog/server-side-rendering-react-hydration-best-practices/#summary</a></li>\n<li><a href=\"https://velog.io/@huurray/React-Hydration-%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC\">https://velog.io/@huurray/React-Hydration-에-대하여</a></li>\n<li><a href=\"https://helloinyong.tistory.com/315\">https://helloinyong.tistory.com/315</a></li>\n<li><a href=\"https://velog.io/@hyemin916/%EB%B2%88%EC%97%AD-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%95%B1SSR%EC%9D%98-Hydration-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\">https://velog.io/@hyemin916/번역-리액트-앱SSR의-Hydration-이해하기</a></li>\n</ul>\n","category":"Troubleshooting","date":"2023-06-09T00:00:00.000+09:00","thumbnail":{"__typename":"Asset","url":"https://images.ctfassets.net/98cksird3kze/1aSjwwZ9CchJJCAK8ED6ew/40539531bd28edceb0b5dfe40f9c9c66/pexels-pixabay-327090.jpeg"}}}],["$","$Le",null,{}]]
